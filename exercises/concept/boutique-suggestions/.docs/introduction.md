# Introduction

## List Comprehensions

Comprehensions provide a facility for transforming *Enumerables* easily and declaratively.

To declare a very simple comprehension, we can use the `for` keyword followed by a *generator* and a *do-block* which creates the new values from the enumerated values.

``` elixir
for n <- [0, 1, 2, 3], do: n + 1
# => [1, 2, 3, 4]
```

Comprehensions can also have *filters*. Values that do not pass the filter are removed from the final list:

``` elixir
for n <- [0, 1, 2, 3], n > 1, do: n + 1
# => [3, 4]
```

We can declare more complicated comprehensions over several lines:

``` elixir
for {atom, number} <- [a: 1, b: 2, c: 3, d: 4],
    rem(number, 2) == 0 do
  atom
end
# => [:b, :d]
```

A *cartesian product* can be created using multiple generators. That means that each value generated by the first generator will be paired once with each value generated by the second generator:

``` elixir
for x <- [0, 1],
    y <- [0, 1] do
  {x, y}
end
# => [{0, 0}, {0, 1}, {1, 0}, {1, 1}]
```
